# Generated from src/antlr2/ChartParser.g4 by ANTLR 4.9.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3:")
        buf.write("\u013e\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\3\2\6\2,\n\2\r\2\16\2-\3\2\3\2\3")
        buf.write("\3\3\3\5\3\64\n\3\3\4\3\4\3\4\3\4\3\4\3\4\6\4<\n\4\r\4")
        buf.write("\16\4=\3\4\3\4\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\6\5J\n")
        buf.write("\5\r\5\16\5K\3\5\3\5\5\5P\n\5\3\6\3\6\6\6T\n\6\r\6\16")
        buf.write("\6U\3\6\3\6\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3")
        buf.write("\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7")
        buf.write("\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3")
        buf.write("\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7")
        buf.write("\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3")
        buf.write("\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7")
        buf.write("\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3")
        buf.write("\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7")
        buf.write("\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3")
        buf.write("\7\3\7\3\7\3\7\3\7\3\7\3\7\5\7\u00d7\n\7\3\b\3\b\3\b\3")
        buf.write("\b\3\b\3\b\5\b\u00df\n\b\3\t\3\t\3\n\3\n\3\13\3\13\3\13")
        buf.write("\7\13\u00e8\n\13\f\13\16\13\u00eb\13\13\3\f\3\f\3\f\3")
        buf.write("\f\3\r\3\r\3\16\3\16\3\17\3\17\3\20\5\20\u00f8\n\20\3")
        buf.write("\20\5\20\u00fb\n\20\3\20\7\20\u00fe\n\20\f\20\16\20\u0101")
        buf.write("\13\20\3\20\3\20\3\20\5\20\u0106\n\20\3\20\7\20\u0109")
        buf.write("\n\20\f\20\16\20\u010c\13\20\3\20\5\20\u010f\n\20\3\21")
        buf.write("\5\21\u0112\n\21\3\21\3\21\5\21\u0116\n\21\3\21\3\21\5")
        buf.write("\21\u011a\n\21\3\21\3\21\5\21\u011e\n\21\3\22\5\22\u0121")
        buf.write("\n\22\3\22\3\22\5\22\u0125\n\22\3\22\3\22\5\22\u0129\n")
        buf.write("\22\3\22\3\22\5\22\u012d\n\22\7\22\u012f\n\22\f\22\16")
        buf.write("\22\u0132\13\22\3\23\3\23\3\23\3\23\5\23\u0138\n\23\3")
        buf.write("\24\3\24\3\25\3\25\3\25\2\2\26\2\4\6\b\n\f\16\20\22\24")
        buf.write("\26\30\32\34\36 \"$&(\2\6\3\2\21\23\3\2\"#\3\2(+\3\2,")
        buf.write("\61\2\u0157\2+\3\2\2\2\4\63\3\2\2\2\6\65\3\2\2\2\bA\3")
        buf.write("\2\2\2\nQ\3\2\2\2\f\u00d6\3\2\2\2\16\u00de\3\2\2\2\20")
        buf.write("\u00e0\3\2\2\2\22\u00e2\3\2\2\2\24\u00e4\3\2\2\2\26\u00ec")
        buf.write("\3\2\2\2\30\u00f0\3\2\2\2\32\u00f2\3\2\2\2\34\u00f4\3")
        buf.write("\2\2\2\36\u00f7\3\2\2\2 \u0111\3\2\2\2\"\u0120\3\2\2\2")
        buf.write("$\u0133\3\2\2\2&\u0139\3\2\2\2(\u013b\3\2\2\2*,\5\4\3")
        buf.write("\2+*\3\2\2\2,-\3\2\2\2-+\3\2\2\2-.\3\2\2\2./\3\2\2\2/")
        buf.write("\60\7\2\2\3\60\3\3\2\2\2\61\64\5\6\4\2\62\64\5\b\5\2\63")
        buf.write("\61\3\2\2\2\63\62\3\2\2\2\64\5\3\2\2\2\65\66\78\2\2\66")
        buf.write("\67\7\64\2\2\678\5\36\20\289\7\65\2\29;\7\66\2\2:<\5\4")
        buf.write("\3\2;:\3\2\2\2<=\3\2\2\2=;\3\2\2\2=>\3\2\2\2>?\3\2\2\2")
        buf.write("?@\7\67\2\2@\7\3\2\2\2AB\7\3\2\2BC\5\16\b\2CD\7\4\2\2")
        buf.write("DE\5\20\t\2EF\7\5\2\2FO\5\f\7\2GI\7\66\2\2HJ\5\4\3\2I")
        buf.write("H\3\2\2\2JK\3\2\2\2KI\3\2\2\2KL\3\2\2\2LM\3\2\2\2MN\7")
        buf.write("\67\2\2NP\3\2\2\2OG\3\2\2\2OP\3\2\2\2P\t\3\2\2\2QS\7\66")
        buf.write("\2\2RT\5\4\3\2SR\3\2\2\2TU\3\2\2\2US\3\2\2\2UV\3\2\2\2")
        buf.write("VW\3\2\2\2WX\7\67\2\2X\13\3\2\2\2YZ\7\6\2\2Z[\5\22\n\2")
        buf.write("[\\\7&\2\2\\]\5\32\16\2]\u00d7\3\2\2\2^_\7\7\2\2_`\5\22")
        buf.write("\n\2`a\7&\2\2ab\5\32\16\2b\u00d7\3\2\2\2cd\7\b\2\2de\5")
        buf.write("\22\n\2ef\7&\2\2fg\5\32\16\2g\u00d7\3\2\2\2hi\7\t\2\2")
        buf.write("ij\5\22\n\2jk\7&\2\2kl\5\32\16\2l\u00d7\3\2\2\2mn\7\6")
        buf.write("\2\2no\5\22\n\2op\7\n\2\2pq\5\30\r\2qr\7&\2\2rs\5\32\16")
        buf.write("\2s\u00d7\3\2\2\2tu\7\6\2\2uv\5\22\n\2vw\7\13\2\2wx\5")
        buf.write("\30\r\2xy\7&\2\2yz\5\32\16\2z\u00d7\3\2\2\2{|\7\7\2\2")
        buf.write("|}\7\24\2\2}~\5\30\r\2~\177\7&\2\2\177\u0080\5\32\16\2")
        buf.write("\u0080\u00d7\3\2\2\2\u0081\u0082\7\f\2\2\u0082\u0083\5")
        buf.write("\22\n\2\u0083\u0084\7\r\2\2\u0084\u0085\5\30\r\2\u0085")
        buf.write("\u0086\7&\2\2\u0086\u0087\5\32\16\2\u0087\u00d7\3\2\2")
        buf.write("\2\u0088\u0089\7\f\2\2\u0089\u008a\5\22\n\2\u008a\u008b")
        buf.write("\7\16\2\2\u008b\u008c\5\30\r\2\u008c\u008d\7&\2\2\u008d")
        buf.write("\u008e\5\32\16\2\u008e\u00d7\3\2\2\2\u008f\u0090\7\17")
        buf.write("\2\2\u0090\u0091\5\24\13\2\u0091\u0092\7\"\2\2\u0092\u0093")
        buf.write("\5\24\13\2\u0093\u00d7\3\2\2\2\u0094\u0095\7\20\2\2\u0095")
        buf.write("\u0096\5\34\17\2\u0096\u0097\5\24\13\2\u0097\u0098\7\4")
        buf.write("\2\2\u0098\u0099\5\26\f\2\u0099\u00d7\3\2\2\2\u009a\u009b")
        buf.write("\7\25\2\2\u009b\u009c\5\22\n\2\u009c\u009d\7!\2\2\u009d")
        buf.write("\u009e\5\32\16\2\u009e\u00d7\3\2\2\2\u009f\u00a0\7\26")
        buf.write("\2\2\u00a0\u00a1\5\22\n\2\u00a1\u00a2\7!\2\2\u00a2\u00a3")
        buf.write("\5\32\16\2\u00a3\u00d7\3\2\2\2\u00a4\u00a5\7\27\2\2\u00a5")
        buf.write("\u00a6\5\22\n\2\u00a6\u00a7\7!\2\2\u00a7\u00a8\5\32\16")
        buf.write("\2\u00a8\u00d7\3\2\2\2\u00a9\u00aa\7\30\2\2\u00aa\u00ab")
        buf.write("\5\22\n\2\u00ab\u00ac\7!\2\2\u00ac\u00ad\5\26\f\2\u00ad")
        buf.write("\u00d7\3\2\2\2\u00ae\u00af\7\31\2\2\u00af\u00b0\5\22\n")
        buf.write("\2\u00b0\u00b1\7!\2\2\u00b1\u00b2\5\26\f\2\u00b2\u00d7")
        buf.write("\3\2\2\2\u00b3\u00b4\7\32\2\2\u00b4\u00b5\5\26\f\2\u00b5")
        buf.write("\u00b6\7 \2\2\u00b6\u00d7\3\2\2\2\u00b7\u00b8\7\33\2\2")
        buf.write("\u00b8\u00b9\5\24\13\2\u00b9\u00ba\7&\2\2\u00ba\u00bb")
        buf.write("\5\32\16\2\u00bb\u00bc\7\4\2\2\u00bc\u00bd\5\26\f\2\u00bd")
        buf.write("\u00d7\3\2\2\2\u00be\u00bf\7\34\2\2\u00bf\u00c0\5\24\13")
        buf.write("\2\u00c0\u00c1\7&\2\2\u00c1\u00c2\5\32\16\2\u00c2\u00d7")
        buf.write("\3\2\2\2\u00c3\u00c4\7\35\2\2\u00c4\u00c5\5\22\n\2\u00c5")
        buf.write("\u00c6\7\"\2\2\u00c6\u00c7\5\22\n\2\u00c7\u00d7\3\2\2")
        buf.write("\2\u00c8\u00c9\7\36\2\2\u00c9\u00ca\5\22\n\2\u00ca\u00cb")
        buf.write("\7\"\2\2\u00cb\u00cc\5\22\n\2\u00cc\u00d7\3\2\2\2\u00cd")
        buf.write("\u00ce\7\37\2\2\u00ce\u00cf\5\22\n\2\u00cf\u00d0\7\62")
        buf.write("\2\2\u00d0\u00d1\5\22\n\2\u00d1\u00d2\7\62\2\2\u00d2\u00d3")
        buf.write("\5\22\n\2\u00d3\u00d4\7&\2\2\u00d4\u00d5\5\32\16\2\u00d5")
        buf.write("\u00d7\3\2\2\2\u00d6Y\3\2\2\2\u00d6^\3\2\2\2\u00d6c\3")
        buf.write("\2\2\2\u00d6h\3\2\2\2\u00d6m\3\2\2\2\u00d6t\3\2\2\2\u00d6")
        buf.write("{\3\2\2\2\u00d6\u0081\3\2\2\2\u00d6\u0088\3\2\2\2\u00d6")
        buf.write("\u008f\3\2\2\2\u00d6\u0094\3\2\2\2\u00d6\u009a\3\2\2\2")
        buf.write("\u00d6\u009f\3\2\2\2\u00d6\u00a4\3\2\2\2\u00d6\u00a9\3")
        buf.write("\2\2\2\u00d6\u00ae\3\2\2\2\u00d6\u00b3\3\2\2\2\u00d6\u00b7")
        buf.write("\3\2\2\2\u00d6\u00be\3\2\2\2\u00d6\u00c3\3\2\2\2\u00d6")
        buf.write("\u00c8\3\2\2\2\u00d6\u00cd\3\2\2\2\u00d7\r\3\2\2\2\u00d8")
        buf.write("\u00df\5\22\n\2\u00d9\u00df\5\24\13\2\u00da\u00db\5\22")
        buf.write("\n\2\u00db\u00dc\7$\2\2\u00dc\u00dd\5\22\n\2\u00dd\u00df")
        buf.write("\3\2\2\2\u00de\u00d8\3\2\2\2\u00de\u00d9\3\2\2\2\u00de")
        buf.write("\u00da\3\2\2\2\u00df\17\3\2\2\2\u00e0\u00e1\79\2\2\u00e1")
        buf.write("\21\3\2\2\2\u00e2\u00e3\79\2\2\u00e3\23\3\2\2\2\u00e4")
        buf.write("\u00e9\79\2\2\u00e5\u00e6\7\62\2\2\u00e6\u00e8\79\2\2")
        buf.write("\u00e7\u00e5\3\2\2\2\u00e8\u00eb\3\2\2\2\u00e9\u00e7\3")
        buf.write("\2\2\2\u00e9\u00ea\3\2\2\2\u00ea\25\3\2\2\2\u00eb\u00e9")
        buf.write("\3\2\2\2\u00ec\u00ed\79\2\2\u00ed\u00ee\7%\2\2\u00ee\u00ef")
        buf.write("\79\2\2\u00ef\27\3\2\2\2\u00f0\u00f1\79\2\2\u00f1\31\3")
        buf.write("\2\2\2\u00f2\u00f3\79\2\2\u00f3\33\3\2\2\2\u00f4\u00f5")
        buf.write("\t\2\2\2\u00f5\35\3\2\2\2\u00f6\u00f8\7\'\2\2\u00f7\u00f6")
        buf.write("\3\2\2\2\u00f7\u00f8\3\2\2\2\u00f8\u00fa\3\2\2\2\u00f9")
        buf.write("\u00fb\7\64\2\2\u00fa\u00f9\3\2\2\2\u00fa\u00fb\3\2\2")
        buf.write("\2\u00fb\u00ff\3\2\2\2\u00fc\u00fe\7\'\2\2\u00fd\u00fc")
        buf.write("\3\2\2\2\u00fe\u0101\3\2\2\2\u00ff\u00fd\3\2\2\2\u00ff")
        buf.write("\u0100\3\2\2\2\u0100\u0102\3\2\2\2\u0101\u00ff\3\2\2\2")
        buf.write("\u0102\u010a\5 \21\2\u0103\u0105\t\3\2\2\u0104\u0106\7")
        buf.write("\'\2\2\u0105\u0104\3\2\2\2\u0105\u0106\3\2\2\2\u0106\u0107")
        buf.write("\3\2\2\2\u0107\u0109\5 \21\2\u0108\u0103\3\2\2\2\u0109")
        buf.write("\u010c\3\2\2\2\u010a\u0108\3\2\2\2\u010a\u010b\3\2\2\2")
        buf.write("\u010b\u010e\3\2\2\2\u010c\u010a\3\2\2\2\u010d\u010f\7")
        buf.write("\'\2\2\u010e\u010d\3\2\2\2\u010e\u010f\3\2\2\2\u010f\37")
        buf.write("\3\2\2\2\u0110\u0112\7\64\2\2\u0111\u0110\3\2\2\2\u0111")
        buf.write("\u0112\3\2\2\2\u0112\u0113\3\2\2\2\u0113\u0115\5\"\22")
        buf.write("\2\u0114\u0116\7\65\2\2\u0115\u0114\3\2\2\2\u0115\u0116")
        buf.write("\3\2\2\2\u0116\u0117\3\2\2\2\u0117\u0119\5(\25\2\u0118")
        buf.write("\u011a\7\64\2\2\u0119\u0118\3\2\2\2\u0119\u011a\3\2\2")
        buf.write("\2\u011a\u011b\3\2\2\2\u011b\u011d\5\"\22\2\u011c\u011e")
        buf.write("\7\65\2\2\u011d\u011c\3\2\2\2\u011d\u011e\3\2\2\2\u011e")
        buf.write("!\3\2\2\2\u011f\u0121\7\64\2\2\u0120\u011f\3\2\2\2\u0120")
        buf.write("\u0121\3\2\2\2\u0121\u0122\3\2\2\2\u0122\u0124\5$\23\2")
        buf.write("\u0123\u0125\7\65\2\2\u0124\u0123\3\2\2\2\u0124\u0125")
        buf.write("\3\2\2\2\u0125\u0130\3\2\2\2\u0126\u0128\5&\24\2\u0127")
        buf.write("\u0129\7\64\2\2\u0128\u0127\3\2\2\2\u0128\u0129\3\2\2")
        buf.write("\2\u0129\u012a\3\2\2\2\u012a\u012c\5$\23\2\u012b\u012d")
        buf.write("\7\65\2\2\u012c\u012b\3\2\2\2\u012c\u012d\3\2\2\2\u012d")
        buf.write("\u012f\3\2\2\2\u012e\u0126\3\2\2\2\u012f\u0132\3\2\2\2")
        buf.write("\u0130\u012e\3\2\2\2\u0130\u0131\3\2\2\2\u0131#\3\2\2")
        buf.write("\2\u0132\u0130\3\2\2\2\u0133\u0137\79\2\2\u0134\u0135")
        buf.write("\5&\24\2\u0135\u0136\79\2\2\u0136\u0138\3\2\2\2\u0137")
        buf.write("\u0134\3\2\2\2\u0137\u0138\3\2\2\2\u0138%\3\2\2\2\u0139")
        buf.write("\u013a\t\4\2\2\u013a\'\3\2\2\2\u013b\u013c\t\5\2\2\u013c")
        buf.write(")\3\2\2\2\33-\63=KOU\u00d6\u00de\u00e9\u00f7\u00fa\u00ff")
        buf.write("\u0105\u010a\u010e\u0111\u0115\u0119\u011d\u0120\u0124")
        buf.write("\u0128\u012c\u0130\u0137")
        return buf.getvalue()


class ChartParser ( Parser ):

    grammarFileName = "ChartParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'with'", "'from'", "'chart:'", "'compare'", 
                     "'differences'", "'contrast'", "'versus'", "'split by'", 
                     "'grouped by'", "'show'", "'stacked by'", "'subgroups'", 
                     "'show correlation between'", "'log'", "'progression of'", 
                     "'trend of'", "'growth of'", "'within'", "'show proportion of'", 
                     "'show share of'", "'show percentage of'", "'show frequency of'", 
                     "'show distribution of'", "'show frequency in'", "'accumulation of'", 
                     "'stacked trend of'", "'scatter plot of'", "'pattern of'", 
                     "'bubble of'", "'buckets'", "'by'", "'and'", "'or'", 
                     "'at'", "'to'", "'for'", "'!'", "'+'", "'-'", "'*'", 
                     "'/'", "'<'", "'<='", "'>'", "'>='", "'=='", "'!='", 
                     "','", "':'", "'('", "')'", "'{'", "'}'", "'while'" ]

    symbolicNames = [ "<INVALID>", "WITH", "FROM", "CHART", "COMPARE", "DIFFERENCES", 
                      "CONTRAST", "VERSUS", "SPLIT_BY", "GROUPED_BY", "SHOW", 
                      "STACKED_BY", "SUBGROUPS", "CORRELATION", "LOG", "PROGRESSION_OF", 
                      "TREND_OF", "GROWTH_OF", "WITHIN", "SHOW_PROPORTION", 
                      "SHOW_SHARE", "SHOW_PERCENTAGE", "SHOW_FREQUENCY", 
                      "SHOW_DISTRIBUTION", "SHOW_FREQUENCY_BUCKETS", "ACCUMULATION", 
                      "STACKED_TREND", "SCATTER_PLOT", "PATTERN", "BUBBLE", 
                      "BUCKETS", "BY", "AND", "OR", "AT", "TO", "FOR", "NOT", 
                      "PLUS", "MINUS", "MULTIPLY", "DIVIDE", "LT", "LTE", 
                      "GT", "GTE", "EQ", "NEQ", "COMMA", "COLON", "LPAREN", 
                      "RPAREN", "LBRACE", "RBRACE", "WHILE", "IDENTIFIER", 
                      "WS" ]

    RULE_program = 0
    RULE_statement = 1
    RULE_loop = 2
    RULE_command = 3
    RULE_block = 4
    RULE_chartFunction = 5
    RULE_data = 6
    RULE_table = 7
    RULE_var = 8
    RULE_continuousVar = 9
    RULE_range = 10
    RULE_subgroup = 11
    RULE_cases = 12
    RULE_trendKeyword = 13
    RULE_condition = 14
    RULE_logicalOperation = 15
    RULE_operationBody = 16
    RULE_operation = 17
    RULE_operationSign = 18
    RULE_logicalOperationSign = 19

    ruleNames =  [ "program", "statement", "loop", "command", "block", "chartFunction", 
                   "data", "table", "var", "continuousVar", "range", "subgroup", 
                   "cases", "trendKeyword", "condition", "logicalOperation", 
                   "operationBody", "operation", "operationSign", "logicalOperationSign" ]

    EOF = Token.EOF
    WITH=1
    FROM=2
    CHART=3
    COMPARE=4
    DIFFERENCES=5
    CONTRAST=6
    VERSUS=7
    SPLIT_BY=8
    GROUPED_BY=9
    SHOW=10
    STACKED_BY=11
    SUBGROUPS=12
    CORRELATION=13
    LOG=14
    PROGRESSION_OF=15
    TREND_OF=16
    GROWTH_OF=17
    WITHIN=18
    SHOW_PROPORTION=19
    SHOW_SHARE=20
    SHOW_PERCENTAGE=21
    SHOW_FREQUENCY=22
    SHOW_DISTRIBUTION=23
    SHOW_FREQUENCY_BUCKETS=24
    ACCUMULATION=25
    STACKED_TREND=26
    SCATTER_PLOT=27
    PATTERN=28
    BUBBLE=29
    BUCKETS=30
    BY=31
    AND=32
    OR=33
    AT=34
    TO=35
    FOR=36
    NOT=37
    PLUS=38
    MINUS=39
    MULTIPLY=40
    DIVIDE=41
    LT=42
    LTE=43
    GT=44
    GTE=45
    EQ=46
    NEQ=47
    COMMA=48
    COLON=49
    LPAREN=50
    RPAREN=51
    LBRACE=52
    RBRACE=53
    WHILE=54
    IDENTIFIER=55
    WS=56

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(ChartParser.EOF, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ChartParser.StatementContext)
            else:
                return self.getTypedRuleContext(ChartParser.StatementContext,i)


        def getRuleIndex(self):
            return ChartParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)




    def program(self):

        localctx = ChartParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 41 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 40
                self.statement()
                self.state = 43 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==ChartParser.WITH or _la==ChartParser.WHILE):
                    break

            self.state = 45
            self.match(ChartParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loop(self):
            return self.getTypedRuleContext(ChartParser.LoopContext,0)


        def command(self):
            return self.getTypedRuleContext(ChartParser.CommandContext,0)


        def getRuleIndex(self):
            return ChartParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)




    def statement(self):

        localctx = ChartParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_statement)
        try:
            self.state = 49
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ChartParser.WHILE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 47
                self.loop()
                pass
            elif token in [ChartParser.WITH]:
                self.enterOuterAlt(localctx, 2)
                self.state = 48
                self.command()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LoopContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHILE(self):
            return self.getToken(ChartParser.WHILE, 0)

        def LPAREN(self):
            return self.getToken(ChartParser.LPAREN, 0)

        def condition(self):
            return self.getTypedRuleContext(ChartParser.ConditionContext,0)


        def RPAREN(self):
            return self.getToken(ChartParser.RPAREN, 0)

        def LBRACE(self):
            return self.getToken(ChartParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(ChartParser.RBRACE, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ChartParser.StatementContext)
            else:
                return self.getTypedRuleContext(ChartParser.StatementContext,i)


        def getRuleIndex(self):
            return ChartParser.RULE_loop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoop" ):
                listener.enterLoop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoop" ):
                listener.exitLoop(self)




    def loop(self):

        localctx = ChartParser.LoopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_loop)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 51
            self.match(ChartParser.WHILE)
            self.state = 52
            self.match(ChartParser.LPAREN)
            self.state = 53
            self.condition()
            self.state = 54
            self.match(ChartParser.RPAREN)
            self.state = 55
            self.match(ChartParser.LBRACE)
            self.state = 57 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 56
                self.statement()
                self.state = 59 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==ChartParser.WITH or _la==ChartParser.WHILE):
                    break

            self.state = 61
            self.match(ChartParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CommandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITH(self):
            return self.getToken(ChartParser.WITH, 0)

        def data(self):
            return self.getTypedRuleContext(ChartParser.DataContext,0)


        def FROM(self):
            return self.getToken(ChartParser.FROM, 0)

        def table(self):
            return self.getTypedRuleContext(ChartParser.TableContext,0)


        def CHART(self):
            return self.getToken(ChartParser.CHART, 0)

        def chartFunction(self):
            return self.getTypedRuleContext(ChartParser.ChartFunctionContext,0)


        def LBRACE(self):
            return self.getToken(ChartParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(ChartParser.RBRACE, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ChartParser.StatementContext)
            else:
                return self.getTypedRuleContext(ChartParser.StatementContext,i)


        def getRuleIndex(self):
            return ChartParser.RULE_command

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCommand" ):
                listener.enterCommand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCommand" ):
                listener.exitCommand(self)




    def command(self):

        localctx = ChartParser.CommandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_command)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 63
            self.match(ChartParser.WITH)
            self.state = 64
            self.data()
            self.state = 65
            self.match(ChartParser.FROM)
            self.state = 66
            self.table()
            self.state = 67
            self.match(ChartParser.CHART)
            self.state = 68
            self.chartFunction()
            self.state = 77
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ChartParser.LBRACE:
                self.state = 69
                self.match(ChartParser.LBRACE)
                self.state = 71 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 70
                    self.statement()
                    self.state = 73 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==ChartParser.WITH or _la==ChartParser.WHILE):
                        break

                self.state = 75
                self.match(ChartParser.RBRACE)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(ChartParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(ChartParser.RBRACE, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ChartParser.StatementContext)
            else:
                return self.getTypedRuleContext(ChartParser.StatementContext,i)


        def getRuleIndex(self):
            return ChartParser.RULE_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlock" ):
                listener.enterBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlock" ):
                listener.exitBlock(self)




    def block(self):

        localctx = ChartParser.BlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_block)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 79
            self.match(ChartParser.LBRACE)
            self.state = 81 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 80
                self.statement()
                self.state = 83 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==ChartParser.WITH or _la==ChartParser.WHILE):
                    break

            self.state = 85
            self.match(ChartParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ChartFunctionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMPARE(self):
            return self.getToken(ChartParser.COMPARE, 0)

        def var(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ChartParser.VarContext)
            else:
                return self.getTypedRuleContext(ChartParser.VarContext,i)


        def FOR(self):
            return self.getToken(ChartParser.FOR, 0)

        def cases(self):
            return self.getTypedRuleContext(ChartParser.CasesContext,0)


        def DIFFERENCES(self):
            return self.getToken(ChartParser.DIFFERENCES, 0)

        def CONTRAST(self):
            return self.getToken(ChartParser.CONTRAST, 0)

        def VERSUS(self):
            return self.getToken(ChartParser.VERSUS, 0)

        def SPLIT_BY(self):
            return self.getToken(ChartParser.SPLIT_BY, 0)

        def subgroup(self):
            return self.getTypedRuleContext(ChartParser.SubgroupContext,0)


        def GROUPED_BY(self):
            return self.getToken(ChartParser.GROUPED_BY, 0)

        def WITHIN(self):
            return self.getToken(ChartParser.WITHIN, 0)

        def SHOW(self):
            return self.getToken(ChartParser.SHOW, 0)

        def STACKED_BY(self):
            return self.getToken(ChartParser.STACKED_BY, 0)

        def SUBGROUPS(self):
            return self.getToken(ChartParser.SUBGROUPS, 0)

        def CORRELATION(self):
            return self.getToken(ChartParser.CORRELATION, 0)

        def continuousVar(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ChartParser.ContinuousVarContext)
            else:
                return self.getTypedRuleContext(ChartParser.ContinuousVarContext,i)


        def AND(self):
            return self.getToken(ChartParser.AND, 0)

        def LOG(self):
            return self.getToken(ChartParser.LOG, 0)

        def trendKeyword(self):
            return self.getTypedRuleContext(ChartParser.TrendKeywordContext,0)


        def FROM(self):
            return self.getToken(ChartParser.FROM, 0)

        def range(self):
            return self.getTypedRuleContext(ChartParser.RangeContext,0)


        def SHOW_PROPORTION(self):
            return self.getToken(ChartParser.SHOW_PROPORTION, 0)

        def BY(self):
            return self.getToken(ChartParser.BY, 0)

        def SHOW_SHARE(self):
            return self.getToken(ChartParser.SHOW_SHARE, 0)

        def SHOW_PERCENTAGE(self):
            return self.getToken(ChartParser.SHOW_PERCENTAGE, 0)

        def SHOW_FREQUENCY(self):
            return self.getToken(ChartParser.SHOW_FREQUENCY, 0)

        def SHOW_DISTRIBUTION(self):
            return self.getToken(ChartParser.SHOW_DISTRIBUTION, 0)

        def SHOW_FREQUENCY_BUCKETS(self):
            return self.getToken(ChartParser.SHOW_FREQUENCY_BUCKETS, 0)

        def BUCKETS(self):
            return self.getToken(ChartParser.BUCKETS, 0)

        def ACCUMULATION(self):
            return self.getToken(ChartParser.ACCUMULATION, 0)

        def STACKED_TREND(self):
            return self.getToken(ChartParser.STACKED_TREND, 0)

        def SCATTER_PLOT(self):
            return self.getToken(ChartParser.SCATTER_PLOT, 0)

        def PATTERN(self):
            return self.getToken(ChartParser.PATTERN, 0)

        def BUBBLE(self):
            return self.getToken(ChartParser.BUBBLE, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(ChartParser.COMMA)
            else:
                return self.getToken(ChartParser.COMMA, i)

        def getRuleIndex(self):
            return ChartParser.RULE_chartFunction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChartFunction" ):
                listener.enterChartFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChartFunction" ):
                listener.exitChartFunction(self)




    def chartFunction(self):

        localctx = ChartParser.ChartFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_chartFunction)
        try:
            self.state = 212
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 87
                self.match(ChartParser.COMPARE)
                self.state = 88
                self.var()
                self.state = 89
                self.match(ChartParser.FOR)
                self.state = 90
                self.cases()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 92
                self.match(ChartParser.DIFFERENCES)
                self.state = 93
                self.var()
                self.state = 94
                self.match(ChartParser.FOR)
                self.state = 95
                self.cases()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 97
                self.match(ChartParser.CONTRAST)
                self.state = 98
                self.var()
                self.state = 99
                self.match(ChartParser.FOR)
                self.state = 100
                self.cases()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 102
                self.match(ChartParser.VERSUS)
                self.state = 103
                self.var()
                self.state = 104
                self.match(ChartParser.FOR)
                self.state = 105
                self.cases()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 107
                self.match(ChartParser.COMPARE)
                self.state = 108
                self.var()
                self.state = 109
                self.match(ChartParser.SPLIT_BY)
                self.state = 110
                self.subgroup()
                self.state = 111
                self.match(ChartParser.FOR)
                self.state = 112
                self.cases()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 114
                self.match(ChartParser.COMPARE)
                self.state = 115
                self.var()
                self.state = 116
                self.match(ChartParser.GROUPED_BY)
                self.state = 117
                self.subgroup()
                self.state = 118
                self.match(ChartParser.FOR)
                self.state = 119
                self.cases()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 121
                self.match(ChartParser.DIFFERENCES)
                self.state = 122
                self.match(ChartParser.WITHIN)
                self.state = 123
                self.subgroup()
                self.state = 124
                self.match(ChartParser.FOR)
                self.state = 125
                self.cases()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 127
                self.match(ChartParser.SHOW)
                self.state = 128
                self.var()
                self.state = 129
                self.match(ChartParser.STACKED_BY)
                self.state = 130
                self.subgroup()
                self.state = 131
                self.match(ChartParser.FOR)
                self.state = 132
                self.cases()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 134
                self.match(ChartParser.SHOW)
                self.state = 135
                self.var()
                self.state = 136
                self.match(ChartParser.SUBGROUPS)
                self.state = 137
                self.subgroup()
                self.state = 138
                self.match(ChartParser.FOR)
                self.state = 139
                self.cases()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 141
                self.match(ChartParser.CORRELATION)
                self.state = 142
                self.continuousVar()
                self.state = 143
                self.match(ChartParser.AND)
                self.state = 144
                self.continuousVar()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 146
                self.match(ChartParser.LOG)
                self.state = 147
                self.trendKeyword()
                self.state = 148
                self.continuousVar()
                self.state = 149
                self.match(ChartParser.FROM)
                self.state = 150
                self.range()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 152
                self.match(ChartParser.SHOW_PROPORTION)
                self.state = 153
                self.var()
                self.state = 154
                self.match(ChartParser.BY)
                self.state = 155
                self.cases()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 157
                self.match(ChartParser.SHOW_SHARE)
                self.state = 158
                self.var()
                self.state = 159
                self.match(ChartParser.BY)
                self.state = 160
                self.cases()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 162
                self.match(ChartParser.SHOW_PERCENTAGE)
                self.state = 163
                self.var()
                self.state = 164
                self.match(ChartParser.BY)
                self.state = 165
                self.cases()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 167
                self.match(ChartParser.SHOW_FREQUENCY)
                self.state = 168
                self.var()
                self.state = 169
                self.match(ChartParser.BY)
                self.state = 170
                self.range()
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 172
                self.match(ChartParser.SHOW_DISTRIBUTION)
                self.state = 173
                self.var()
                self.state = 174
                self.match(ChartParser.BY)
                self.state = 175
                self.range()
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 177
                self.match(ChartParser.SHOW_FREQUENCY_BUCKETS)
                self.state = 178
                self.range()
                self.state = 179
                self.match(ChartParser.BUCKETS)
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 181
                self.match(ChartParser.ACCUMULATION)
                self.state = 182
                self.continuousVar()
                self.state = 183
                self.match(ChartParser.FOR)
                self.state = 184
                self.cases()
                self.state = 185
                self.match(ChartParser.FROM)
                self.state = 186
                self.range()
                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 188
                self.match(ChartParser.STACKED_TREND)
                self.state = 189
                self.continuousVar()
                self.state = 190
                self.match(ChartParser.FOR)
                self.state = 191
                self.cases()
                pass

            elif la_ == 20:
                self.enterOuterAlt(localctx, 20)
                self.state = 193
                self.match(ChartParser.SCATTER_PLOT)
                self.state = 194
                self.var()
                self.state = 195
                self.match(ChartParser.AND)
                self.state = 196
                self.var()
                pass

            elif la_ == 21:
                self.enterOuterAlt(localctx, 21)
                self.state = 198
                self.match(ChartParser.PATTERN)
                self.state = 199
                self.var()
                self.state = 200
                self.match(ChartParser.AND)
                self.state = 201
                self.var()
                pass

            elif la_ == 22:
                self.enterOuterAlt(localctx, 22)
                self.state = 203
                self.match(ChartParser.BUBBLE)
                self.state = 204
                self.var()
                self.state = 205
                self.match(ChartParser.COMMA)
                self.state = 206
                self.var()
                self.state = 207
                self.match(ChartParser.COMMA)
                self.state = 208
                self.var()
                self.state = 209
                self.match(ChartParser.FOR)
                self.state = 210
                self.cases()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DataContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ChartParser.VarContext)
            else:
                return self.getTypedRuleContext(ChartParser.VarContext,i)


        def continuousVar(self):
            return self.getTypedRuleContext(ChartParser.ContinuousVarContext,0)


        def AT(self):
            return self.getToken(ChartParser.AT, 0)

        def getRuleIndex(self):
            return ChartParser.RULE_data

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterData" ):
                listener.enterData(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitData" ):
                listener.exitData(self)




    def data(self):

        localctx = ChartParser.DataContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_data)
        try:
            self.state = 220
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 214
                self.var()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 215
                self.continuousVar()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 216
                self.var()
                self.state = 217
                self.match(ChartParser.AT)
                self.state = 218
                self.var()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(ChartParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return ChartParser.RULE_table

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable" ):
                listener.enterTable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable" ):
                listener.exitTable(self)




    def table(self):

        localctx = ChartParser.TableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_table)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 222
            self.match(ChartParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VarContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(ChartParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return ChartParser.RULE_var

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar" ):
                listener.enterVar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar" ):
                listener.exitVar(self)




    def var(self):

        localctx = ChartParser.VarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_var)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 224
            self.match(ChartParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ContinuousVarContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(ChartParser.IDENTIFIER)
            else:
                return self.getToken(ChartParser.IDENTIFIER, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(ChartParser.COMMA)
            else:
                return self.getToken(ChartParser.COMMA, i)

        def getRuleIndex(self):
            return ChartParser.RULE_continuousVar

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContinuousVar" ):
                listener.enterContinuousVar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContinuousVar" ):
                listener.exitContinuousVar(self)




    def continuousVar(self):

        localctx = ChartParser.ContinuousVarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_continuousVar)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 226
            self.match(ChartParser.IDENTIFIER)
            self.state = 231
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==ChartParser.COMMA:
                self.state = 227
                self.match(ChartParser.COMMA)
                self.state = 228
                self.match(ChartParser.IDENTIFIER)
                self.state = 233
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RangeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(ChartParser.IDENTIFIER)
            else:
                return self.getToken(ChartParser.IDENTIFIER, i)

        def TO(self):
            return self.getToken(ChartParser.TO, 0)

        def getRuleIndex(self):
            return ChartParser.RULE_range

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRange" ):
                listener.enterRange(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRange" ):
                listener.exitRange(self)




    def range(self):

        localctx = ChartParser.RangeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_range)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 234
            self.match(ChartParser.IDENTIFIER)
            self.state = 235
            self.match(ChartParser.TO)
            self.state = 236
            self.match(ChartParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SubgroupContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(ChartParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return ChartParser.RULE_subgroup

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubgroup" ):
                listener.enterSubgroup(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubgroup" ):
                listener.exitSubgroup(self)




    def subgroup(self):

        localctx = ChartParser.SubgroupContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_subgroup)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 238
            self.match(ChartParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CasesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(ChartParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return ChartParser.RULE_cases

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCases" ):
                listener.enterCases(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCases" ):
                listener.exitCases(self)




    def cases(self):

        localctx = ChartParser.CasesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_cases)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 240
            self.match(ChartParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TrendKeywordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PROGRESSION_OF(self):
            return self.getToken(ChartParser.PROGRESSION_OF, 0)

        def TREND_OF(self):
            return self.getToken(ChartParser.TREND_OF, 0)

        def GROWTH_OF(self):
            return self.getToken(ChartParser.GROWTH_OF, 0)

        def getRuleIndex(self):
            return ChartParser.RULE_trendKeyword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrendKeyword" ):
                listener.enterTrendKeyword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrendKeyword" ):
                listener.exitTrendKeyword(self)




    def trendKeyword(self):

        localctx = ChartParser.TrendKeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_trendKeyword)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 242
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ChartParser.PROGRESSION_OF) | (1 << ChartParser.TREND_OF) | (1 << ChartParser.GROWTH_OF))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalOperation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ChartParser.LogicalOperationContext)
            else:
                return self.getTypedRuleContext(ChartParser.LogicalOperationContext,i)


        def NOT(self, i:int=None):
            if i is None:
                return self.getTokens(ChartParser.NOT)
            else:
                return self.getToken(ChartParser.NOT, i)

        def LPAREN(self):
            return self.getToken(ChartParser.LPAREN, 0)

        def AND(self, i:int=None):
            if i is None:
                return self.getTokens(ChartParser.AND)
            else:
                return self.getToken(ChartParser.AND, i)

        def OR(self, i:int=None):
            if i is None:
                return self.getTokens(ChartParser.OR)
            else:
                return self.getToken(ChartParser.OR, i)

        def getRuleIndex(self):
            return ChartParser.RULE_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondition" ):
                listener.enterCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondition" ):
                listener.exitCondition(self)




    def condition(self):

        localctx = ChartParser.ConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_condition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 245
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                self.state = 244
                self.match(ChartParser.NOT)


            self.state = 248
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
            if la_ == 1:
                self.state = 247
                self.match(ChartParser.LPAREN)


            self.state = 253
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==ChartParser.NOT:
                self.state = 250
                self.match(ChartParser.NOT)
                self.state = 255
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 256
            self.logicalOperation()
            self.state = 264
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==ChartParser.AND or _la==ChartParser.OR:
                self.state = 257
                _la = self._input.LA(1)
                if not(_la==ChartParser.AND or _la==ChartParser.OR):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 259
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==ChartParser.NOT:
                    self.state = 258
                    self.match(ChartParser.NOT)


                self.state = 261
                self.logicalOperation()
                self.state = 266
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 268
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ChartParser.NOT:
                self.state = 267
                self.match(ChartParser.NOT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LogicalOperationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def operationBody(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ChartParser.OperationBodyContext)
            else:
                return self.getTypedRuleContext(ChartParser.OperationBodyContext,i)


        def logicalOperationSign(self):
            return self.getTypedRuleContext(ChartParser.LogicalOperationSignContext,0)


        def LPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(ChartParser.LPAREN)
            else:
                return self.getToken(ChartParser.LPAREN, i)

        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(ChartParser.RPAREN)
            else:
                return self.getToken(ChartParser.RPAREN, i)

        def getRuleIndex(self):
            return ChartParser.RULE_logicalOperation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalOperation" ):
                listener.enterLogicalOperation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalOperation" ):
                listener.exitLogicalOperation(self)




    def logicalOperation(self):

        localctx = ChartParser.LogicalOperationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_logicalOperation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 271
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                self.state = 270
                self.match(ChartParser.LPAREN)


            self.state = 273
            self.operationBody()
            self.state = 275
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ChartParser.RPAREN:
                self.state = 274
                self.match(ChartParser.RPAREN)


            self.state = 277
            self.logicalOperationSign()
            self.state = 279
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                self.state = 278
                self.match(ChartParser.LPAREN)


            self.state = 281
            self.operationBody()
            self.state = 283
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
            if la_ == 1:
                self.state = 282
                self.match(ChartParser.RPAREN)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OperationBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def operation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ChartParser.OperationContext)
            else:
                return self.getTypedRuleContext(ChartParser.OperationContext,i)


        def LPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(ChartParser.LPAREN)
            else:
                return self.getToken(ChartParser.LPAREN, i)

        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(ChartParser.RPAREN)
            else:
                return self.getToken(ChartParser.RPAREN, i)

        def operationSign(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ChartParser.OperationSignContext)
            else:
                return self.getTypedRuleContext(ChartParser.OperationSignContext,i)


        def getRuleIndex(self):
            return ChartParser.RULE_operationBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperationBody" ):
                listener.enterOperationBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperationBody" ):
                listener.exitOperationBody(self)




    def operationBody(self):

        localctx = ChartParser.OperationBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_operationBody)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 286
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ChartParser.LPAREN:
                self.state = 285
                self.match(ChartParser.LPAREN)


            self.state = 288
            self.operation()
            self.state = 290
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,20,self._ctx)
            if la_ == 1:
                self.state = 289
                self.match(ChartParser.RPAREN)


            self.state = 302
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ChartParser.PLUS) | (1 << ChartParser.MINUS) | (1 << ChartParser.MULTIPLY) | (1 << ChartParser.DIVIDE))) != 0):
                self.state = 292
                self.operationSign()
                self.state = 294
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==ChartParser.LPAREN:
                    self.state = 293
                    self.match(ChartParser.LPAREN)


                self.state = 296
                self.operation()
                self.state = 298
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
                if la_ == 1:
                    self.state = 297
                    self.match(ChartParser.RPAREN)


                self.state = 304
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OperationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(ChartParser.IDENTIFIER)
            else:
                return self.getToken(ChartParser.IDENTIFIER, i)

        def operationSign(self):
            return self.getTypedRuleContext(ChartParser.OperationSignContext,0)


        def getRuleIndex(self):
            return ChartParser.RULE_operation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperation" ):
                listener.enterOperation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperation" ):
                listener.exitOperation(self)




    def operation(self):

        localctx = ChartParser.OperationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_operation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 305
            self.match(ChartParser.IDENTIFIER)
            self.state = 309
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,24,self._ctx)
            if la_ == 1:
                self.state = 306
                self.operationSign()
                self.state = 307
                self.match(ChartParser.IDENTIFIER)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OperationSignContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(ChartParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(ChartParser.MINUS, 0)

        def MULTIPLY(self):
            return self.getToken(ChartParser.MULTIPLY, 0)

        def DIVIDE(self):
            return self.getToken(ChartParser.DIVIDE, 0)

        def getRuleIndex(self):
            return ChartParser.RULE_operationSign

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperationSign" ):
                listener.enterOperationSign(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperationSign" ):
                listener.exitOperationSign(self)




    def operationSign(self):

        localctx = ChartParser.OperationSignContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_operationSign)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 311
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ChartParser.PLUS) | (1 << ChartParser.MINUS) | (1 << ChartParser.MULTIPLY) | (1 << ChartParser.DIVIDE))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LogicalOperationSignContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT(self):
            return self.getToken(ChartParser.LT, 0)

        def LTE(self):
            return self.getToken(ChartParser.LTE, 0)

        def GT(self):
            return self.getToken(ChartParser.GT, 0)

        def GTE(self):
            return self.getToken(ChartParser.GTE, 0)

        def EQ(self):
            return self.getToken(ChartParser.EQ, 0)

        def NEQ(self):
            return self.getToken(ChartParser.NEQ, 0)

        def getRuleIndex(self):
            return ChartParser.RULE_logicalOperationSign

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalOperationSign" ):
                listener.enterLogicalOperationSign(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalOperationSign" ):
                listener.exitLogicalOperationSign(self)




    def logicalOperationSign(self):

        localctx = ChartParser.LogicalOperationSignContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_logicalOperationSign)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 313
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ChartParser.LT) | (1 << ChartParser.LTE) | (1 << ChartParser.GT) | (1 << ChartParser.GTE) | (1 << ChartParser.EQ) | (1 << ChartParser.NEQ))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





