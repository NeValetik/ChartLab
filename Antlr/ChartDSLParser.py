# Generated from ChartDSL.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,58,273,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,1,0,1,0,1,0,1,
        0,1,0,1,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,3,1,172,8,1,1,2,1,2,1,3,1,3,1,3,1,3,1,3,1,3,3,3,182,8,3,1,
        4,1,4,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,3,5,194,8,5,1,6,1,6,1,6,1,
        6,3,6,200,8,6,1,7,1,7,1,7,1,7,1,8,1,8,1,8,1,8,1,8,1,8,1,9,1,9,1,
        9,1,9,1,9,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,3,10,225,8,10,
        1,10,1,10,1,10,5,10,230,8,10,10,10,12,10,233,9,10,1,11,1,11,1,11,
        1,11,1,12,1,12,1,12,1,12,1,12,1,12,3,12,245,8,12,1,12,1,12,1,12,
        1,12,5,12,251,8,12,10,12,12,12,254,9,12,1,13,1,13,1,13,1,13,1,13,
        3,13,261,8,13,1,14,1,14,1,15,1,15,1,16,1,16,1,17,1,17,1,18,1,18,
        1,18,0,2,20,24,19,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,
        34,36,0,4,2,0,16,16,41,41,1,0,42,45,1,0,46,51,1,0,52,54,284,0,38,
        1,0,0,0,2,171,1,0,0,0,4,173,1,0,0,0,6,181,1,0,0,0,8,183,1,0,0,0,
        10,193,1,0,0,0,12,199,1,0,0,0,14,201,1,0,0,0,16,205,1,0,0,0,18,211,
        1,0,0,0,20,224,1,0,0,0,22,234,1,0,0,0,24,244,1,0,0,0,26,260,1,0,
        0,0,28,262,1,0,0,0,30,264,1,0,0,0,32,266,1,0,0,0,34,268,1,0,0,0,
        36,270,1,0,0,0,38,39,5,55,0,0,39,40,5,1,0,0,40,41,3,6,3,0,41,42,
        5,2,0,0,42,43,3,4,2,0,43,44,5,3,0,0,44,45,3,2,1,0,45,46,5,56,0,0,
        46,1,1,0,0,0,47,48,5,4,0,0,48,49,3,8,4,0,49,50,5,5,0,0,50,51,3,34,
        17,0,51,172,1,0,0,0,52,53,5,6,0,0,53,54,3,8,4,0,54,55,5,5,0,0,55,
        56,3,34,17,0,56,172,1,0,0,0,57,58,5,7,0,0,58,59,3,8,4,0,59,60,5,
        5,0,0,60,61,3,34,17,0,61,172,1,0,0,0,62,63,5,8,0,0,63,64,3,8,4,0,
        64,65,5,5,0,0,65,66,3,34,17,0,66,172,1,0,0,0,67,68,5,4,0,0,68,69,
        3,8,4,0,69,70,5,9,0,0,70,71,3,32,16,0,71,72,5,5,0,0,72,73,3,34,17,
        0,73,172,1,0,0,0,74,75,5,4,0,0,75,76,3,8,4,0,76,77,5,10,0,0,77,78,
        3,32,16,0,78,79,5,5,0,0,79,80,3,34,17,0,80,172,1,0,0,0,81,82,5,11,
        0,0,82,83,3,32,16,0,83,84,5,5,0,0,84,85,3,34,17,0,85,172,1,0,0,0,
        86,87,5,12,0,0,87,88,3,8,4,0,88,89,5,13,0,0,89,90,3,32,16,0,90,91,
        5,5,0,0,91,92,3,34,17,0,92,172,1,0,0,0,93,94,5,12,0,0,94,95,3,8,
        4,0,95,96,5,14,0,0,96,97,3,32,16,0,97,98,5,5,0,0,98,99,3,34,17,0,
        99,172,1,0,0,0,100,101,5,15,0,0,101,102,3,12,6,0,102,103,5,16,0,
        0,103,104,3,12,6,0,104,172,1,0,0,0,105,106,5,17,0,0,106,107,3,36,
        18,0,107,108,3,12,6,0,108,109,5,2,0,0,109,110,3,14,7,0,110,172,1,
        0,0,0,111,112,5,18,0,0,112,113,3,8,4,0,113,114,5,19,0,0,114,115,
        3,34,17,0,115,172,1,0,0,0,116,117,5,20,0,0,117,118,3,8,4,0,118,119,
        5,19,0,0,119,120,3,34,17,0,120,172,1,0,0,0,121,122,5,21,0,0,122,
        123,3,8,4,0,123,124,5,19,0,0,124,125,3,34,17,0,125,172,1,0,0,0,126,
        127,5,22,0,0,127,128,3,8,4,0,128,129,5,19,0,0,129,130,3,14,7,0,130,
        172,1,0,0,0,131,132,5,23,0,0,132,133,3,8,4,0,133,134,5,19,0,0,134,
        135,3,14,7,0,135,172,1,0,0,0,136,137,5,24,0,0,137,138,3,14,7,0,138,
        139,5,25,0,0,139,172,1,0,0,0,140,141,5,26,0,0,141,142,3,12,6,0,142,
        143,5,5,0,0,143,144,3,34,17,0,144,145,5,2,0,0,145,146,3,14,7,0,146,
        172,1,0,0,0,147,148,5,27,0,0,148,149,3,12,6,0,149,150,5,5,0,0,150,
        151,3,34,17,0,151,172,1,0,0,0,152,153,5,28,0,0,153,154,3,8,4,0,154,
        155,5,16,0,0,155,156,3,8,4,0,156,172,1,0,0,0,157,158,5,29,0,0,158,
        159,3,8,4,0,159,160,5,16,0,0,160,161,3,8,4,0,161,172,1,0,0,0,162,
        163,5,30,0,0,163,164,3,8,4,0,164,165,5,31,0,0,165,166,3,8,4,0,166,
        167,5,31,0,0,167,168,3,8,4,0,168,169,5,5,0,0,169,170,3,34,17,0,170,
        172,1,0,0,0,171,47,1,0,0,0,171,52,1,0,0,0,171,57,1,0,0,0,171,62,
        1,0,0,0,171,67,1,0,0,0,171,74,1,0,0,0,171,81,1,0,0,0,171,86,1,0,
        0,0,171,93,1,0,0,0,171,100,1,0,0,0,171,105,1,0,0,0,171,111,1,0,0,
        0,171,116,1,0,0,0,171,121,1,0,0,0,171,126,1,0,0,0,171,131,1,0,0,
        0,171,136,1,0,0,0,171,140,1,0,0,0,171,147,1,0,0,0,171,152,1,0,0,
        0,171,157,1,0,0,0,171,162,1,0,0,0,172,3,1,0,0,0,173,174,5,57,0,0,
        174,5,1,0,0,0,175,182,3,8,4,0,176,182,3,12,6,0,177,178,3,8,4,0,178,
        179,5,32,0,0,179,180,3,8,4,0,180,182,1,0,0,0,181,175,1,0,0,0,181,
        176,1,0,0,0,181,177,1,0,0,0,182,7,1,0,0,0,183,184,5,57,0,0,184,9,
        1,0,0,0,185,186,3,8,4,0,186,187,5,33,0,0,187,188,5,57,0,0,188,194,
        1,0,0,0,189,190,3,8,4,0,190,191,5,33,0,0,191,192,3,12,6,0,192,194,
        1,0,0,0,193,185,1,0,0,0,193,189,1,0,0,0,194,11,1,0,0,0,195,200,5,
        57,0,0,196,197,5,57,0,0,197,198,5,31,0,0,198,200,3,12,6,0,199,195,
        1,0,0,0,199,196,1,0,0,0,200,13,1,0,0,0,201,202,5,57,0,0,202,203,
        5,34,0,0,203,204,5,57,0,0,204,15,1,0,0,0,205,206,5,35,0,0,206,207,
        5,36,0,0,207,208,3,20,10,0,208,209,5,37,0,0,209,210,5,38,0,0,210,
        17,1,0,0,0,211,212,5,39,0,0,212,213,5,36,0,0,213,214,3,20,10,0,214,
        215,5,37,0,0,215,19,1,0,0,0,216,217,6,10,-1,0,217,225,3,22,11,0,
        218,219,5,40,0,0,219,225,3,20,10,3,220,221,5,36,0,0,221,222,3,20,
        10,0,222,223,5,37,0,0,223,225,1,0,0,0,224,216,1,0,0,0,224,218,1,
        0,0,0,224,220,1,0,0,0,225,231,1,0,0,0,226,227,10,2,0,0,227,228,7,
        0,0,0,228,230,3,20,10,3,229,226,1,0,0,0,230,233,1,0,0,0,231,229,
        1,0,0,0,231,232,1,0,0,0,232,21,1,0,0,0,233,231,1,0,0,0,234,235,3,
        24,12,0,235,236,3,30,15,0,236,237,3,24,12,0,237,23,1,0,0,0,238,239,
        6,12,-1,0,239,245,3,26,13,0,240,241,5,36,0,0,241,242,3,26,13,0,242,
        243,5,37,0,0,243,245,1,0,0,0,244,238,1,0,0,0,244,240,1,0,0,0,245,
        252,1,0,0,0,246,247,10,1,0,0,247,248,3,28,14,0,248,249,3,24,12,2,
        249,251,1,0,0,0,250,246,1,0,0,0,251,254,1,0,0,0,252,250,1,0,0,0,
        252,253,1,0,0,0,253,25,1,0,0,0,254,252,1,0,0,0,255,261,5,57,0,0,
        256,257,5,57,0,0,257,258,3,28,14,0,258,259,5,57,0,0,259,261,1,0,
        0,0,260,255,1,0,0,0,260,256,1,0,0,0,261,27,1,0,0,0,262,263,7,1,0,
        0,263,29,1,0,0,0,264,265,7,2,0,0,265,31,1,0,0,0,266,267,5,57,0,0,
        267,33,1,0,0,0,268,269,5,57,0,0,269,35,1,0,0,0,270,271,7,3,0,0,271,
        37,1,0,0,0,9,171,181,193,199,224,231,244,252,260
    ]

class ChartDSLParser ( Parser ):

    grammarFileName = "ChartDSL.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'with'", "'from'", "'chart:'", "'compare'", 
                     "'for'", "'differences'", "'contrast'", "'versus'", 
                     "'split by'", "'grouped by'", "'differences within'", 
                     "'show'", "'stacked by'", "'subgroups'", "'show correlation between'", 
                     "'and'", "'log'", "'show proportion of'", "'by'", "'show share of'", 
                     "'show percentage of'", "'show frequency of'", "'show distribution of'", 
                     "'show frequency in'", "'buckets'", "'accumulation of'", 
                     "'stacked trend of'", "'scatter plot of'", "'pattern of'", 
                     "'bubble of'", "','", "'at'", "'='", "'to'", "'while'", 
                     "'('", "')'", "':'", "'if'", "'!'", "'or'", "'+'", 
                     "'-'", "'*'", "'/'", "'<'", "'<='", "'>'", "'>='", 
                     "'=='", "'!='", "'progression of'", "'trend of'", "'growth of'", 
                     "'BEGIN'", "'END'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "START_PROGRAM", 
                      "END_PROGRAM", "IDENTIFIER", "WS" ]

    RULE_command = 0
    RULE_chartFunction = 1
    RULE_table = 2
    RULE_data = 3
    RULE_var = 4
    RULE_definition = 5
    RULE_continuousIdentifier = 6
    RULE_range = 7
    RULE_loop = 8
    RULE_conditionalStatement = 9
    RULE_condition = 10
    RULE_logicalOperation = 11
    RULE_operationBody = 12
    RULE_operation = 13
    RULE_operationSign = 14
    RULE_logicalOperationSign = 15
    RULE_subgroup = 16
    RULE_cases = 17
    RULE_trendKeyword = 18

    ruleNames =  [ "command", "chartFunction", "table", "data", "var", "definition", 
                   "continuousIdentifier", "range", "loop", "conditionalStatement", 
                   "condition", "logicalOperation", "operationBody", "operation", 
                   "operationSign", "logicalOperationSign", "subgroup", 
                   "cases", "trendKeyword" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    START_PROGRAM=55
    END_PROGRAM=56
    IDENTIFIER=57
    WS=58

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class CommandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def START_PROGRAM(self):
            return self.getToken(ChartDSLParser.START_PROGRAM, 0)

        def data(self):
            return self.getTypedRuleContext(ChartDSLParser.DataContext,0)


        def table(self):
            return self.getTypedRuleContext(ChartDSLParser.TableContext,0)


        def chartFunction(self):
            return self.getTypedRuleContext(ChartDSLParser.ChartFunctionContext,0)


        def END_PROGRAM(self):
            return self.getToken(ChartDSLParser.END_PROGRAM, 0)

        def getRuleIndex(self):
            return ChartDSLParser.RULE_command

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCommand" ):
                listener.enterCommand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCommand" ):
                listener.exitCommand(self)




    def command(self):

        localctx = ChartDSLParser.CommandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_command)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 38
            self.match(ChartDSLParser.START_PROGRAM)
            self.state = 39
            self.match(ChartDSLParser.T__0)
            self.state = 40
            self.data()
            self.state = 41
            self.match(ChartDSLParser.T__1)
            self.state = 42
            self.table()
            self.state = 43
            self.match(ChartDSLParser.T__2)
            self.state = 44
            self.chartFunction()
            self.state = 45
            self.match(ChartDSLParser.END_PROGRAM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChartFunctionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ChartDSLParser.VarContext)
            else:
                return self.getTypedRuleContext(ChartDSLParser.VarContext,i)


        def cases(self):
            return self.getTypedRuleContext(ChartDSLParser.CasesContext,0)


        def subgroup(self):
            return self.getTypedRuleContext(ChartDSLParser.SubgroupContext,0)


        def continuousIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ChartDSLParser.ContinuousIdentifierContext)
            else:
                return self.getTypedRuleContext(ChartDSLParser.ContinuousIdentifierContext,i)


        def trendKeyword(self):
            return self.getTypedRuleContext(ChartDSLParser.TrendKeywordContext,0)


        def range_(self):
            return self.getTypedRuleContext(ChartDSLParser.RangeContext,0)


        def getRuleIndex(self):
            return ChartDSLParser.RULE_chartFunction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChartFunction" ):
                listener.enterChartFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChartFunction" ):
                listener.exitChartFunction(self)




    def chartFunction(self):

        localctx = ChartDSLParser.ChartFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_chartFunction)
        try:
            self.state = 171
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 47
                self.match(ChartDSLParser.T__3)
                self.state = 48
                self.var()
                self.state = 49
                self.match(ChartDSLParser.T__4)
                self.state = 50
                self.cases()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 52
                self.match(ChartDSLParser.T__5)
                self.state = 53
                self.var()
                self.state = 54
                self.match(ChartDSLParser.T__4)
                self.state = 55
                self.cases()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 57
                self.match(ChartDSLParser.T__6)
                self.state = 58
                self.var()
                self.state = 59
                self.match(ChartDSLParser.T__4)
                self.state = 60
                self.cases()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 62
                self.match(ChartDSLParser.T__7)
                self.state = 63
                self.var()
                self.state = 64
                self.match(ChartDSLParser.T__4)
                self.state = 65
                self.cases()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 67
                self.match(ChartDSLParser.T__3)
                self.state = 68
                self.var()
                self.state = 69
                self.match(ChartDSLParser.T__8)
                self.state = 70
                self.subgroup()
                self.state = 71
                self.match(ChartDSLParser.T__4)
                self.state = 72
                self.cases()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 74
                self.match(ChartDSLParser.T__3)
                self.state = 75
                self.var()
                self.state = 76
                self.match(ChartDSLParser.T__9)
                self.state = 77
                self.subgroup()
                self.state = 78
                self.match(ChartDSLParser.T__4)
                self.state = 79
                self.cases()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 81
                self.match(ChartDSLParser.T__10)
                self.state = 82
                self.subgroup()
                self.state = 83
                self.match(ChartDSLParser.T__4)
                self.state = 84
                self.cases()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 86
                self.match(ChartDSLParser.T__11)
                self.state = 87
                self.var()
                self.state = 88
                self.match(ChartDSLParser.T__12)
                self.state = 89
                self.subgroup()
                self.state = 90
                self.match(ChartDSLParser.T__4)
                self.state = 91
                self.cases()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 93
                self.match(ChartDSLParser.T__11)
                self.state = 94
                self.var()
                self.state = 95
                self.match(ChartDSLParser.T__13)
                self.state = 96
                self.subgroup()
                self.state = 97
                self.match(ChartDSLParser.T__4)
                self.state = 98
                self.cases()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 100
                self.match(ChartDSLParser.T__14)
                self.state = 101
                self.continuousIdentifier()
                self.state = 102
                self.match(ChartDSLParser.T__15)
                self.state = 103
                self.continuousIdentifier()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 105
                self.match(ChartDSLParser.T__16)
                self.state = 106
                self.trendKeyword()
                self.state = 107
                self.continuousIdentifier()
                self.state = 108
                self.match(ChartDSLParser.T__1)
                self.state = 109
                self.range_()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 111
                self.match(ChartDSLParser.T__17)
                self.state = 112
                self.var()
                self.state = 113
                self.match(ChartDSLParser.T__18)
                self.state = 114
                self.cases()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 116
                self.match(ChartDSLParser.T__19)
                self.state = 117
                self.var()
                self.state = 118
                self.match(ChartDSLParser.T__18)
                self.state = 119
                self.cases()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 121
                self.match(ChartDSLParser.T__20)
                self.state = 122
                self.var()
                self.state = 123
                self.match(ChartDSLParser.T__18)
                self.state = 124
                self.cases()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 126
                self.match(ChartDSLParser.T__21)
                self.state = 127
                self.var()
                self.state = 128
                self.match(ChartDSLParser.T__18)
                self.state = 129
                self.range_()
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 131
                self.match(ChartDSLParser.T__22)
                self.state = 132
                self.var()
                self.state = 133
                self.match(ChartDSLParser.T__18)
                self.state = 134
                self.range_()
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 136
                self.match(ChartDSLParser.T__23)
                self.state = 137
                self.range_()
                self.state = 138
                self.match(ChartDSLParser.T__24)
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 140
                self.match(ChartDSLParser.T__25)
                self.state = 141
                self.continuousIdentifier()
                self.state = 142
                self.match(ChartDSLParser.T__4)
                self.state = 143
                self.cases()
                self.state = 144
                self.match(ChartDSLParser.T__1)
                self.state = 145
                self.range_()
                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 147
                self.match(ChartDSLParser.T__26)
                self.state = 148
                self.continuousIdentifier()
                self.state = 149
                self.match(ChartDSLParser.T__4)
                self.state = 150
                self.cases()
                pass

            elif la_ == 20:
                self.enterOuterAlt(localctx, 20)
                self.state = 152
                self.match(ChartDSLParser.T__27)
                self.state = 153
                self.var()
                self.state = 154
                self.match(ChartDSLParser.T__15)
                self.state = 155
                self.var()
                pass

            elif la_ == 21:
                self.enterOuterAlt(localctx, 21)
                self.state = 157
                self.match(ChartDSLParser.T__28)
                self.state = 158
                self.var()
                self.state = 159
                self.match(ChartDSLParser.T__15)
                self.state = 160
                self.var()
                pass

            elif la_ == 22:
                self.enterOuterAlt(localctx, 22)
                self.state = 162
                self.match(ChartDSLParser.T__29)
                self.state = 163
                self.var()
                self.state = 164
                self.match(ChartDSLParser.T__30)
                self.state = 165
                self.var()
                self.state = 166
                self.match(ChartDSLParser.T__30)
                self.state = 167
                self.var()
                self.state = 168
                self.match(ChartDSLParser.T__4)
                self.state = 169
                self.cases()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(ChartDSLParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return ChartDSLParser.RULE_table

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable" ):
                listener.enterTable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable" ):
                listener.exitTable(self)




    def table(self):

        localctx = ChartDSLParser.TableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_table)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 173
            self.match(ChartDSLParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ChartDSLParser.VarContext)
            else:
                return self.getTypedRuleContext(ChartDSLParser.VarContext,i)


        def continuousIdentifier(self):
            return self.getTypedRuleContext(ChartDSLParser.ContinuousIdentifierContext,0)


        def getRuleIndex(self):
            return ChartDSLParser.RULE_data

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterData" ):
                listener.enterData(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitData" ):
                listener.exitData(self)




    def data(self):

        localctx = ChartDSLParser.DataContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_data)
        try:
            self.state = 181
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 175
                self.var()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 176
                self.continuousIdentifier()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 177
                self.var()
                self.state = 178
                self.match(ChartDSLParser.T__31)
                self.state = 179
                self.var()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(ChartDSLParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return ChartDSLParser.RULE_var

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar" ):
                listener.enterVar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar" ):
                listener.exitVar(self)




    def var(self):

        localctx = ChartDSLParser.VarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_var)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 183
            self.match(ChartDSLParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var(self):
            return self.getTypedRuleContext(ChartDSLParser.VarContext,0)


        def IDENTIFIER(self):
            return self.getToken(ChartDSLParser.IDENTIFIER, 0)

        def continuousIdentifier(self):
            return self.getTypedRuleContext(ChartDSLParser.ContinuousIdentifierContext,0)


        def getRuleIndex(self):
            return ChartDSLParser.RULE_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefinition" ):
                listener.enterDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefinition" ):
                listener.exitDefinition(self)




    def definition(self):

        localctx = ChartDSLParser.DefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_definition)
        try:
            self.state = 193
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 185
                self.var()
                self.state = 186
                self.match(ChartDSLParser.T__32)
                self.state = 187
                self.match(ChartDSLParser.IDENTIFIER)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 189
                self.var()
                self.state = 190
                self.match(ChartDSLParser.T__32)
                self.state = 191
                self.continuousIdentifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ContinuousIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(ChartDSLParser.IDENTIFIER, 0)

        def continuousIdentifier(self):
            return self.getTypedRuleContext(ChartDSLParser.ContinuousIdentifierContext,0)


        def getRuleIndex(self):
            return ChartDSLParser.RULE_continuousIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContinuousIdentifier" ):
                listener.enterContinuousIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContinuousIdentifier" ):
                listener.exitContinuousIdentifier(self)




    def continuousIdentifier(self):

        localctx = ChartDSLParser.ContinuousIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_continuousIdentifier)
        try:
            self.state = 199
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 195
                self.match(ChartDSLParser.IDENTIFIER)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 196
                self.match(ChartDSLParser.IDENTIFIER)
                self.state = 197
                self.match(ChartDSLParser.T__30)
                self.state = 198
                self.continuousIdentifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RangeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(ChartDSLParser.IDENTIFIER)
            else:
                return self.getToken(ChartDSLParser.IDENTIFIER, i)

        def getRuleIndex(self):
            return ChartDSLParser.RULE_range

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRange" ):
                listener.enterRange(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRange" ):
                listener.exitRange(self)




    def range_(self):

        localctx = ChartDSLParser.RangeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_range)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 201
            self.match(ChartDSLParser.IDENTIFIER)
            self.state = 202
            self.match(ChartDSLParser.T__33)
            self.state = 203
            self.match(ChartDSLParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition(self):
            return self.getTypedRuleContext(ChartDSLParser.ConditionContext,0)


        def getRuleIndex(self):
            return ChartDSLParser.RULE_loop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoop" ):
                listener.enterLoop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoop" ):
                listener.exitLoop(self)




    def loop(self):

        localctx = ChartDSLParser.LoopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_loop)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 205
            self.match(ChartDSLParser.T__34)
            self.state = 206
            self.match(ChartDSLParser.T__35)
            self.state = 207
            self.condition(0)
            self.state = 208
            self.match(ChartDSLParser.T__36)
            self.state = 209
            self.match(ChartDSLParser.T__37)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionalStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition(self):
            return self.getTypedRuleContext(ChartDSLParser.ConditionContext,0)


        def getRuleIndex(self):
            return ChartDSLParser.RULE_conditionalStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditionalStatement" ):
                listener.enterConditionalStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditionalStatement" ):
                listener.exitConditionalStatement(self)




    def conditionalStatement(self):

        localctx = ChartDSLParser.ConditionalStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_conditionalStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 211
            self.match(ChartDSLParser.T__38)
            self.state = 212
            self.match(ChartDSLParser.T__35)
            self.state = 213
            self.condition(0)
            self.state = 214
            self.match(ChartDSLParser.T__36)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalOperation(self):
            return self.getTypedRuleContext(ChartDSLParser.LogicalOperationContext,0)


        def condition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ChartDSLParser.ConditionContext)
            else:
                return self.getTypedRuleContext(ChartDSLParser.ConditionContext,i)


        def getRuleIndex(self):
            return ChartDSLParser.RULE_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondition" ):
                listener.enterCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondition" ):
                listener.exitCondition(self)



    def condition(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = ChartDSLParser.ConditionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 20
        self.enterRecursionRule(localctx, 20, self.RULE_condition, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 224
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                self.state = 217
                self.logicalOperation()
                pass

            elif la_ == 2:
                self.state = 218
                self.match(ChartDSLParser.T__39)
                self.state = 219
                self.condition(3)
                pass

            elif la_ == 3:
                self.state = 220
                self.match(ChartDSLParser.T__35)
                self.state = 221
                self.condition(0)
                self.state = 222
                self.match(ChartDSLParser.T__36)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 231
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,5,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = ChartDSLParser.ConditionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_condition)
                    self.state = 226
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 227
                    _la = self._input.LA(1)
                    if not(_la==16 or _la==41):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 228
                    self.condition(3) 
                self.state = 233
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class LogicalOperationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def operationBody(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ChartDSLParser.OperationBodyContext)
            else:
                return self.getTypedRuleContext(ChartDSLParser.OperationBodyContext,i)


        def logicalOperationSign(self):
            return self.getTypedRuleContext(ChartDSLParser.LogicalOperationSignContext,0)


        def getRuleIndex(self):
            return ChartDSLParser.RULE_logicalOperation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalOperation" ):
                listener.enterLogicalOperation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalOperation" ):
                listener.exitLogicalOperation(self)




    def logicalOperation(self):

        localctx = ChartDSLParser.LogicalOperationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_logicalOperation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 234
            self.operationBody(0)
            self.state = 235
            self.logicalOperationSign()
            self.state = 236
            self.operationBody(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperationBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def operation(self):
            return self.getTypedRuleContext(ChartDSLParser.OperationContext,0)


        def operationBody(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ChartDSLParser.OperationBodyContext)
            else:
                return self.getTypedRuleContext(ChartDSLParser.OperationBodyContext,i)


        def operationSign(self):
            return self.getTypedRuleContext(ChartDSLParser.OperationSignContext,0)


        def getRuleIndex(self):
            return ChartDSLParser.RULE_operationBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperationBody" ):
                listener.enterOperationBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperationBody" ):
                listener.exitOperationBody(self)



    def operationBody(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = ChartDSLParser.OperationBodyContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 24
        self.enterRecursionRule(localctx, 24, self.RULE_operationBody, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 244
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [57]:
                self.state = 239
                self.operation()
                pass
            elif token in [36]:
                self.state = 240
                self.match(ChartDSLParser.T__35)
                self.state = 241
                self.operation()
                self.state = 242
                self.match(ChartDSLParser.T__36)
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 252
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,7,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = ChartDSLParser.OperationBodyContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_operationBody)
                    self.state = 246
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 247
                    self.operationSign()
                    self.state = 248
                    self.operationBody(2) 
                self.state = 254
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,7,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class OperationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(ChartDSLParser.IDENTIFIER)
            else:
                return self.getToken(ChartDSLParser.IDENTIFIER, i)

        def operationSign(self):
            return self.getTypedRuleContext(ChartDSLParser.OperationSignContext,0)


        def getRuleIndex(self):
            return ChartDSLParser.RULE_operation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperation" ):
                listener.enterOperation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperation" ):
                listener.exitOperation(self)




    def operation(self):

        localctx = ChartDSLParser.OperationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_operation)
        try:
            self.state = 260
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 255
                self.match(ChartDSLParser.IDENTIFIER)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 256
                self.match(ChartDSLParser.IDENTIFIER)
                self.state = 257
                self.operationSign()
                self.state = 258
                self.match(ChartDSLParser.IDENTIFIER)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperationSignContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ChartDSLParser.RULE_operationSign

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperationSign" ):
                listener.enterOperationSign(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperationSign" ):
                listener.exitOperationSign(self)




    def operationSign(self):

        localctx = ChartDSLParser.OperationSignContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_operationSign)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 262
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 65970697666560) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicalOperationSignContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ChartDSLParser.RULE_logicalOperationSign

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalOperationSign" ):
                listener.enterLogicalOperationSign(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalOperationSign" ):
                listener.exitLogicalOperationSign(self)




    def logicalOperationSign(self):

        localctx = ChartDSLParser.LogicalOperationSignContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_logicalOperationSign)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 264
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 4433230883192832) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubgroupContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(ChartDSLParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return ChartDSLParser.RULE_subgroup

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubgroup" ):
                listener.enterSubgroup(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubgroup" ):
                listener.exitSubgroup(self)




    def subgroup(self):

        localctx = ChartDSLParser.SubgroupContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_subgroup)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 266
            self.match(ChartDSLParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CasesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(ChartDSLParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return ChartDSLParser.RULE_cases

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCases" ):
                listener.enterCases(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCases" ):
                listener.exitCases(self)




    def cases(self):

        localctx = ChartDSLParser.CasesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_cases)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 268
            self.match(ChartDSLParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TrendKeywordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ChartDSLParser.RULE_trendKeyword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrendKeyword" ):
                listener.enterTrendKeyword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrendKeyword" ):
                listener.exitTrendKeyword(self)




    def trendKeyword(self):

        localctx = ChartDSLParser.TrendKeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_trendKeyword)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 270
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 31525197391593472) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[10] = self.condition_sempred
        self._predicates[12] = self.operationBody_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def condition_sempred(self, localctx:ConditionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 2)
         

    def operationBody_sempred(self, localctx:OperationBodyContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 1)
         




